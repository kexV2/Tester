#!/usr/bin/env python3
"""
PenTest Helper - An interactive tool to automate common penetration testing tasks
for educational purposes only.
"""

import sys
import os
import subprocess
import socket
import ipaddress
import time
import threading
import concurrent.futures
import warnings
from datetime import datetime

# Function to install required packages
def install_package(package):
    print(f"[!] {package} not found. Installing...")
    subprocess.call([sys.executable, "-m", "pip", "install", package])
    print(f"[+] {package} installed successfully!")

# Try to import colorama, install if not available
try:
    from colorama import Fore, Style, Back, init
    init()
except ImportError:
    install_package("colorama")
    from colorama import Fore, Style, Back, init
    init()

# Try to import requests, install if not available
try:
    import requests
except ImportError:
    install_package("requests")
    import requests

# Try to import nmap if available
try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False
    print(f"{Fore.YELLOW}[!] Python-nmap module not installed. Advanced scanning functionality will be limited.{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[!] Install with: pip install python-nmap{Style.RESET_ALL}")

# Suppress insecure request warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class PenTester:
    def __init__(self):
        self.target = None
        self.output_dir = "pentest_results"
        self.current_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
    def setup(self):
        """Setup output directory"""
        # Create a timestamped directory
        self.output_dir = f"pentest_results_{self.current_timestamp}"
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            print(f"{Fore.GREEN}[+] Created output directory: {self.output_dir}{Style.RESET_ALL}")
    
    def validate_ip(self, ip):
        """Validate if string is a valid IP address"""
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def validate_target(self, target):
        """Validate if target is IP or hostname"""
        if self.validate_ip(target):
            return target
        else:
            try:
                ip = socket.gethostbyname(target)
                print(f"{Fore.BLUE}[i] Hostname {target} resolves to {ip}{Style.RESET_ALL}")
                return ip
            except socket.gaierror:
                print(f"{Fore.RED}[-] Cannot resolve hostname: {target}{Style.RESET_ALL}")
                return None
                
    def ping_host(self, ip):
        """Ping a single host to check if it's alive"""
        # Different ping command based on platform
        if sys.platform.startswith('win'):
            ping_cmd = ["ping", "-n", "1", "-w", "500", ip]
        else:  # Linux/Unix/Mac
            ping_cmd = ["ping", "-c", "1", "-W", "1", ip]
            
        with open(os.devnull, 'w') as devnull:
            try:
                subprocess.check_call(ping_cmd, stdout=devnull, stderr=devnull)
                return ip
            except subprocess.CalledProcessError:
                return None
                
    def ping_sweep(self, network):
        """Perform a ping sweep on a network"""
        try:
            network = ipaddress.ip_network(network, strict=False)
            print(f"{Fore.BLUE}[i] Starting ping sweep on {network}{Style.RESET_ALL}")
            
            live_hosts = []
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
                futures = []
                for ip in network.hosts():
                    ip_str = str(ip)
                    futures.append(executor.submit(self.ping_host, ip_str))
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        live_hosts.append(result)
                        print(f"{Fore.GREEN}[+] Host is up: {result}{Style.RESET_ALL}")
            
            # Save results
            with open(f"{self.output_dir}/live_hosts.txt", "w") as f:
                for host in live_hosts:
                    f.write(f"{host}\n")
            
            print(f"{Fore.GREEN}[+] Found {len(live_hosts)} live hosts. Results saved to {self.output_dir}/live_hosts.txt{Style.RESET_ALL}")
            return live_hosts
        except Exception as e:
            print(f"{Fore.RED}[-] Error during ping sweep: {str(e)}{Style.RESET_ALL}")
            return []
    
    def port_scan(self, target, ports=None):
        """Scan common ports on a target"""
        if not ports:
            # Common ports to scan
            ports = [21, 22, 23, 25, 53, 80, 88, 110, 111, 135, 139, 143, 389, 443, 445, 465, 587, 
                     993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 5985, 8080, 8443]
        
        print(f"{Fore.BLUE}[i] Starting port scan on {target} ({len(ports)} ports){Style.RESET_ALL}")
        open_ports = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(self.check_port, target, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(futures):
                port = futures[future]
                try:
                    is_open, service = future.result()
                    if is_open:
                        open_ports.append((port, service))
                        print(f"{Fore.GREEN}[+] Port {port}/tcp is open - {service}{Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking port {port}: {str(e)}{Style.RESET_ALL}")
        
        # Save results
        with open(f"{self.output_dir}/{target}_port_scan.txt", "w") as f:
            f.write(f"Port scan results for {target}\n")
            f.write("-" * 50 + "\n")
            for port, service in open_ports:
                f.write(f"{port}/tcp\t{service}\n")
                
        print(f"{Fore.GREEN}[+] Found {len(open_ports)} open ports. Results saved to {self.output_dir}/{target}_port_scan.txt{Style.RESET_ALL}")
        return open_ports
    
    def check_port(self, target, port):
        """Check if a specific port is open on the target"""
        common_services = {
            21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS", 80: "HTTP",
            88: "Kerberos", 110: "POP3", 111: "RPC", 135: "MSRPC", 139: "NetBIOS",
            143: "IMAP", 389: "LDAP", 443: "HTTPS", 445: "SMB", 465: "SMTPS",
            587: "SMTP", 993: "IMAPS", 995: "POP3S", 1433: "MSSQL", 1521: "Oracle",
            3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL", 5900: "VNC",
            5985: "WinRM", 8080: "HTTP-Alt", 8443: "HTTPS-Alt"
        }
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(1)
        try:
            s.connect((target, port))
            service = common_services.get(port, "Unknown")
            return True, service
        except:
            return False, None
        finally:
            s.close()
    
    def service_detection(self, target, open_ports):
        """Detect services running on open ports"""
        if not NMAP_AVAILABLE:
            print(f"{Fore.YELLOW}[!] Skipping service detection - python-nmap not available{Style.RESET_ALL}")
            return
            
        print(f"{Fore.BLUE}[i] Starting service detection on {target}{Style.RESET_ALL}")
        
        ports_str = ",".join([str(port) for port, _ in open_ports])
        
        try:
            nm = nmap.PortScanner()
            nm.scan(target, ports_str, arguments="-sV -T4")
            
            with open(f"{self.output_dir}/{target}_service_detection.txt", "w") as f:
                f.write(f"Service detection results for {target}\n")
                f.write("-" * 50 + "\n")
                
                for port in nm[target]['tcp']:
                    service = nm[target]['tcp'][port]
                    print(f"{Fore.GREEN}[+] Port {port}/tcp - {service['name']} {service['version']}{Style.RESET_ALL}")
                    f.write(f"{port}/tcp\t{service['name']}\t{service['product']} {service['version']}\n")
                    
            print(f"{Fore.GREEN}[+] Service detection completed. Results saved to {self.output_dir}/{target}_service_detection.txt{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[-] Error during service detection: {str(e)}{Style.RESET_ALL}")
    
    def directory_scan(self, target, port=80, wordlist=None):
        """Perform a web directory scan"""
        if port == 443:
            url_base = f"https://{target}"
        else:
            url_base = f"http://{target}:{port}"
            
        if not wordlist:
            # Small built-in wordlist for basic scanning
            dirs = [
                "/", "/admin", "/login", "/wp-admin", "/administrator", "/phpmyadmin",
                "/jenkins", "/wp-login.php", "/admin.php", "/index.php", "/robots.txt",
                "/backup", "/dev", "/test", "/tmp", "/api", "/docs", "/dashboard",
                "/config", "/old", "/new", "/upload", "/uploads", "/files", "/console",
                "/cgi-bin", "/web", "/secret", "/private", "/backup", "/images", "/img"
            ]
        else:
            try:
                with open(wordlist, "r") as f:
                    dirs = [line.strip() for line in f if line.strip()]
            except Exception as e:
                print(f"{Fore.RED}[-] Error reading wordlist: {str(e)}{Style.RESET_ALL}")
                return
        
        print(f"{Fore.BLUE}[i] Starting directory scan on {url_base} ({len(dirs)} paths){Style.RESET_ALL}")
        
        found_urls = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(self.check_url, f"{url_base}{d}"): d for d in dirs}
            
            for future in concurrent.futures.as_completed(futures):
                dir_path = futures[future]
                try:
                    url, status, size = future.result()
                    if url:  # If URL exists (status code < 400)
                        found_urls.append((url, status, size))
                        print(f"{Fore.GREEN}[+] Found: {url} (Status: {status}, Size: {size}){Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking {dir_path}: {str(e)}{Style.RESET_ALL}")
        
        # Save results
        with open(f"{self.output_dir}/{target}_directory_scan.txt", "w") as f:
            f.write(f"Directory scan results for {url_base}\n")
            f.write("-" * 50 + "\n")
            for url, status, size in found_urls:
                f.write(f"{url}\tStatus: {status}\tSize: {size}\n")
                
        print(f"{Fore.GREEN}[+] Directory scan completed. Found {len(found_urls)} paths. Results saved to {self.output_dir}/{target}_directory_scan.txt{Style.RESET_ALL}")
        return found_urls
    
    def check_url(self, url):
        """Check if a URL exists and return its status code and content size"""
        try:
            response = requests.get(url, timeout=3, verify=False, allow_redirects=True)
            if response.status_code < 400:  # Consider all non-error codes as "found"
                return url, response.status_code, len(response.content)
            return None, None, None
        except requests.exceptions.RequestException:
            return None, None, None
    
    def enumerate_subdomains(self, domain, wordlist=None):
        """Enumerate subdomains of a domain"""
        if not wordlist:
            # Small built-in wordlist for basic scanning
            subdomains = [
                "www", "mail", "ftp", "webmail", "login", "admin", "test", "dev",
                "portal", "ns1", "ns2", "smtp", "pop", "m", "blog", "mobile", "api",
                "secure", "vpn", "mx", "support", "remote", "docs", "web", "data", "server"
            ]
        else:
            try:
                with open(wordlist, "r") as f:
                    subdomains = [line.strip() for line in f if line.strip()]
            except Exception as e:
                print(f"{Fore.RED}[-] Error reading wordlist: {str(e)}{Style.RESET_ALL}")
                return
        
        print(f"{Fore.BLUE}[i] Starting subdomain enumeration for {domain} ({len(subdomains)} subdomains){Style.RESET_ALL}")
        
        found_subdomains = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            futures = {executor.submit(self.resolve_subdomain, f"{sub}.{domain}"): sub for sub in subdomains}
            
            for future in concurrent.futures.as_completed(futures):
                subdomain = futures[future]
                try:
                    full_domain, ip = future.result()
                    if ip:  # If subdomain resolves
                        found_subdomains.append((full_domain, ip))
                        print(f"{Fore.GREEN}[+] Found: {full_domain} ({ip}){Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking {subdomain}: {str(e)}{Style.RESET_ALL}")
        
        # Save results
        with open(f"{self.output_dir}/{domain}_subdomains.txt", "w") as f:
            f.write(f"Subdomain enumeration results for {domain}\n")
            f.write("-" * 50 + "\n")
            for subdomain, ip in found_subdomains:
                f.write(f"{subdomain}\t{ip}\n")
                
        print(f"{Fore.GREEN}[+] Subdomain enumeration completed. Found {len(found_subdomains)} subdomains. Results saved to {self.output_dir}/{domain}_subdomains.txt{Style.RESET_ALL}")
        return found_subdomains
    
    def resolve_subdomain(self, domain):
        """Resolve a subdomain to an IP address"""
        try:
            ip = socket.gethostbyname(domain)
            return domain, ip
        except socket.gaierror:
            return None, None
    
    def scan_network(self, target):
        """Full network scan - ping sweep, port scan and service detection"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting network scan on {target}{Style.RESET_ALL}")
        
        # Perform ping sweep to find live hosts
        live_hosts = self.ping_sweep(target)
        
        # Port scan each live host
        for host in live_hosts:
            open_ports = self.port_scan(host)
            
            # Perform service detection on hosts with open ports
            if open_ports and NMAP_AVAILABLE:
                self.service_detection(host, open_ports)
                
            # Check for web servers and perform directory scan
            for port, service in open_ports:
                if service in ["HTTP", "HTTPS"]:
                    self.directory_scan(host, port)
    
    def scan_target(self, target):
        """Full scan of a single target - port scan, service detection and dir scan"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting target scan on {target}{Style.RESET_ALL}")
        
        # Validate and resolve target
        resolved_target = self.validate_target(target)
        if not resolved_target:
            print(f"{Fore.RED}[-] Invalid target: {target}{Style.RESET_ALL}")
            return
            
        # Port scan
        open_ports = self.port_scan(resolved_target)
        
        # Perform service detection on hosts with open ports
        if open_ports and NMAP_AVAILABLE:
            self.service_detection(resolved_target, open_ports)
            
        # Check for web servers and perform directory scan
        for port, service in open_ports:
            if service in ["HTTP", "HTTPS"]:
                self.directory_scan(resolved_target, port)
    
    def scan_domain(self, domain):
        """Full domain scan - subdomain enum, port scan, service detection and dir scan"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting domain scan on {domain}{Style.RESET_ALL}")
        
        # Subdomain enumeration
        subdomains = self.enumerate_subdomains(domain)
        
        # Scan each subdomain
        for subdomain, ip in subdomains:
            open_ports = self.port_scan(ip)
            
            # Perform service detection
            if open_ports and NMAP_AVAILABLE:
                self.service_detection(ip, open_ports)
                
            # Check for web servers and perform directory scan
            for port, service in open_ports:
                if service in ["HTTP", "HTTPS"]:
                    self.directory_scan(subdomain, port)  # Use subdomain instead of IP for URL


def banner():
    """Display script banner"""
    banner_text = f"""
{Fore.CYAN}
 ██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗████████╗
 ██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝
 ██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗   ██║   
 ██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║   ██║   
 ██║     ███████╗██║ ╚████║   ██║   ███████╗███████║   ██║   
 ╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝   ╚═╝   
{Style.RESET_ALL}
{Fore.GREEN}========== Interactive Penetration Testing Tool v1.0 =========={Style.RESET_ALL}
{Fore.YELLOW}================= For Educational Use Only ==================={Style.RESET_ALL}
"""
    print(banner_text)


def display_menu():
    """Display the main menu"""
    os.system('cls' if os.name == 'nt' else 'clear')
    banner()
    print(f"{Fore.CYAN}┌───────────────────────────────────────────────────┐{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.WHITE}{Back.BLUE} PENTEST HELPER - MAIN MENU                      {Style.RESET_ALL} {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}1.{Style.RESET_ALL} Single Target Scan                              {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}2.{Style.RESET_ALL} Network Scan                                    {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}3.{Style.RESET_ALL} Domain Scan (with Subdomains)                   {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}4.{Style.RESET_ALL} Ping Sweep                                      {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}5.{Style.RESET_ALL} Port Scan                                       {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}6.{Style.RESET_ALL} Service Detection                               {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}7.{Style.RESET_ALL} Directory Scan                                  {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}8.{Style.RESET_ALL} Subdomain Enumeration                           {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}0.{Style.RESET_ALL} Exit                                            {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}└───────────────────────────────────────────────────┘{Style.RESET_ALL}")
    print()
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Choose an option: ")

def get_target():
    """Get target from user"""
    print(f"\n{Fore.CYAN}┌───────────────────────────────────────────────────┐{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.WHITE}{Back.BLUE} TARGET INFORMATION                              {Style.RESET_ALL} {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}└───────────────────────────────────────────────────┘{Style.RESET_ALL}")
    print(f"\n{Fore.YELLOW}[i] {Style.RESET_ALL}Examples:")
    print(f"   - Single IP:      192.168.1.1")
    print(f"   - Network range:  192.168.1.0/24")
    print(f"   - Domain:         example.com")
    print()
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter target: ")

def get_ports():
    """Get ports from user"""
    print()
    print(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Examples: 80,443,8080 or leave empty for common ports")
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter ports (comma-separated) or press Enter for defaults: ")

def get_wordlist(type_str):
    """Get wordlist file path from user"""
    print()
    print(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Leave empty to use built-in wordlist")
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter {type_str} wordlist path or press Enter for default: ")

def confirm_action(action, target):
    """Confirm action with user"""
    print()
    print(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Ready to {action} {target}")
    confirm = input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Proceed? (Y/n): ").strip().lower()
    return confirm != 'n'

def display_results_location(directory):
    """Display where results are saved"""
    print()
    print(f"{Fore.CYAN}┌───────────────────────────────────────────────────┐{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.WHITE}{Back.GREEN} SCAN COMPLETED                                 {Style.RESET_ALL} {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}└───────────────────────────────────────────────────┘{Style.RESET_ALL}")
    print(f"\n{Fore.GREEN}[+] {Style.RESET_ALL}Results saved in: {directory}")
    print()
    input(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Press Enter to continue...")

def main():
    """Main function for interactive menu"""
    pentest = PenTester()
    
    while True:
        option = display_menu()
        
        if option == "0":
            print(f"\n{Fore.GREEN}[+] {Style.RESET_ALL}Goodbye!")
            sys.exit(0)
            
        elif option == "1":  # Single Target Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform full scan on", target):
                pentest.setup()
                pentest.scan_target(target)
                display_results_location(pentest.output_dir)
                
        elif option == "2":  # Network Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("scan network", target):
                pentest.setup()
                pentest.scan_network(target)
                display_results_location(pentest.output_dir)
                
        elif option == "3":  # Domain Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("scan domain", target):
                pentest.setup()
                pentest.scan_domain(target)
                display_results_location(pentest.output_dir)
                
        elif option == "4":  # Ping Sweep
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform ping sweep on", target):
                pentest.setup()
                pentest.ping_sweep(target)
                display_results_location(pentest.output_dir)
                
        elif option == "5":  # Port Scan
            target = get_target()
            if not target:
                continue
                
            ports_input = get_ports()
            
            if confirm_action("perform port scan on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    if ports_input:
                        ports = [int(p.strip()) for p in ports_input.split(",") if p.strip()]
                        pentest.port_scan(target_ip, ports)
                    else:
                        pentest.port_scan(target_ip)
                        
                display_results_location(pentest.output_dir)
                
        elif option == "6":  # Service Detection
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform service detection on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    open_ports = pentest.port_scan(target_ip)
                    if open_ports and NMAP_AVAILABLE:
                        pentest.service_detection(target_ip, open_ports)
                    elif not NMAP_AVAILABLE:
                        print(f"{Fore.RED}[-] {Style.RESET_ALL}Python-nmap not available. Install with: pip install python-nmap")
                        time.sleep(3)
                        
                display_results_location(pentest.output_dir)
                
        elif option == "7":  # Directory Scan
            target = get_target()
            if not target:
                continue
                
            ports_input = get_ports()
            wordlist = get_wordlist("directory")
            
            if confirm_action("perform directory scan on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    if ports_input:
                        port = int(ports_input.split(",")[0].strip())
                    else:
                        port = 80
                        
                    pentest.directory_scan(target_ip, port, wordlist if wordlist else None)
                    
                display_results_location(pentest.output_dir)
                
        elif option == "8":  # Subdomain Enumeration
            target = get_target()
            if not target:
                continue
                
            wordlist = get_wordlist("subdomain")
            
            if confirm_action("perform subdomain enumeration on", target):
                pentest.setup()
                pentest.enumerate_subdomains(target, wordlist if wordlist else None)
                display_results_location(pentest.output_dir)
        
        else:
            print(f"\n{Fore.RED}[-] {Style.RESET_ALL}Invalid option! Please try again.")
            time.sleep(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Scan interrupted by user{Style.RESET_ALL}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Fore.RED}[-] An error occurred: {str(e)}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[!] {Style.RESET_ALL}Press Enter to continue...")
        input()
        sys.exit(1)