#!/usr/bin/env python3
"""
PenTest Helper - An interactive tool to automate common penetration testing tasks
for educational purposes only.
"""

import sys
import os
import subprocess
import socket
import ipaddress
import time
import threading
import concurrent.futures
import warnings
from datetime import datetime

# Function to install required packages
def install_package(package):
    print(f"[!] {package} not found. Installing...")
    subprocess.call([sys.executable, "-m", "pip", "install", package])
    print(f"[+] {package} installed successfully!")

# Try to import colorama, install if not available
try:
    from colorama import Fore, Style, Back, init
    init()
except ImportError:
    install_package("colorama")
    from colorama import Fore, Style, Back, init
    init()

# Try to import requests, install if not available
try:
    import requests
except ImportError:
    install_package("requests")
    import requests

# Try to import nmap if available
try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False
    print(f"{Fore.YELLOW}[!] Python-nmap module not installed. Advanced scanning functionality will be limited.{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[!] Install with: pip install python-nmap{Style.RESET_ALL}")

# Suppress insecure request warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class PenTester:
    def __init__(self):
        self.target = None
        self.output_dir = "pentest_results"
        self.current_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
    def setup(self):
        """Setup output directory"""
        # Create a timestamped directory
        self.output_dir = f"pentest_results_{self.current_timestamp}"
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            print(f"{Fore.GREEN}[+] Created output directory: {self.output_dir}{Style.RESET_ALL}")
    
    def validate_ip(self, ip):
        """Validate if string is a valid IP address"""
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def validate_target(self, target):
        """Validate if target is IP or hostname"""
        if self.validate_ip(target):
            return target
        else:
            try:
                ip = socket.gethostbyname(target)
                print(f"{Fore.BLUE}[i] Hostname {target} resolves to {ip}{Style.RESET_ALL}")
                return ip
            except socket.gaierror:
                print(f"{Fore.RED}[-] Cannot resolve hostname: {target}{Style.RESET_ALL}")
                return None
                
    def ping_host(self, ip):
        """Ping a single host to check if it's alive"""
        # Different ping command based on platform
        if sys.platform.startswith('win'):
            ping_cmd = ["ping", "-n", "1", "-w", "500", ip]
        else:  # Linux/Unix/Mac
            ping_cmd = ["ping", "-c", "1", "-W", "1", ip]
            
        with open(os.devnull, 'w') as devnull:
            try:
                subprocess.check_call(ping_cmd, stdout=devnull, stderr=devnull)
                return ip
            except subprocess.CalledProcessError:
                return None
                
    def ping_sweep(self, network):
        """Perform a ping sweep on a network"""
        try:
            network = ipaddress.ip_network(network, strict=False)
            print(f"{Fore.BLUE}[i] Starting ping sweep on {network}{Style.RESET_ALL}")
            
            live_hosts = []
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
                futures = []
                for ip in network.hosts():
                    ip_str = str(ip)
                    futures.append(executor.submit(self.ping_host, ip_str))
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        live_hosts.append(result)
                        print(f"{Fore.GREEN}[+] Host is up: {result}{Style.RESET_ALL}")
            
            # Save results
            with open(f"{self.output_dir}/live_hosts.txt", "w") as f:
                for host in live_hosts:
                    f.write(f"{host}\n")
            
            print(f"{Fore.GREEN}[+] Found {len(live_hosts)} live hosts. Results saved to {self.output_dir}/live_hosts.txt{Style.RESET_ALL}")
            return live_hosts
        except Exception as e:
            print(f"{Fore.RED}[-] Error during ping sweep: {str(e)}{Style.RESET_ALL}")
            return []
    
    def port_scan(self, target, ports=None):
        """Scan common ports on a target"""
        if not ports:
            # Common ports to scan
            ports = [21, 22, 23, 25, 53, 80, 88, 110, 111, 135, 139, 143, 389, 443, 445, 465, 587, 
                     993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 5985, 8080, 8443]
        
        print(f"{Fore.BLUE}[i] Starting port scan on {target} ({len(ports)} ports){Style.RESET_ALL}")
        open_ports = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(self.check_port, target, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(futures):
                port = futures[future]
                try:
                    is_open, service = future.result()
                    if is_open:
                        open_ports.append((port, service))
                        print(f"{Fore.GREEN}[+] Port {port}/tcp is open - {service}{Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking port {port}: {str(e)}{Style.RESET_ALL}")
        
        # Save results
        with open(f"{self.output_dir}/{target}_port_scan.txt", "w") as f:
            f.write(f"Port scan results for {target}\n")
            f.write("-" * 50 + "\n")
            for port, service in open_ports:
                f.write(f"{port}/tcp\t{service}\n")
                
        print(f"{Fore.GREEN}[+] Found {len(open_ports)} open ports. Results saved to {self.output_dir}/{target}_port_scan.txt{Style.RESET_ALL}")
        return open_ports
    
    def check_port(self, target, port):
        """Check if a specific port is open on the target"""
        common_services = {
            21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS", 80: "HTTP",
            88: "Kerberos", 110: "POP3", 111: "RPC", 135: "MSRPC", 139: "NetBIOS",
            143: "IMAP", 389: "LDAP", 443: "HTTPS", 445: "SMB", 465: "SMTPS",
            587: "SMTP", 993: "IMAPS", 995: "POP3S", 1433: "MSSQL", 1521: "Oracle",
            3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL", 5900: "VNC",
            5985: "WinRM", 8080: "HTTP-Alt", 8443: "HTTPS-Alt"
        }
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(1)
        try:
            s.connect((target, port))
            service = common_services.get(port, "Unknown")
            return True, service
        except:
            return False, None
        finally:
            s.close()
    
    def service_detection(self, target, open_ports):
        """Detect services running on open ports"""
        if not NMAP_AVAILABLE:
            print(f"{Fore.YELLOW}[!] Skipping service detection - python-nmap not available{Style.RESET_ALL}")
            return
            
        print(f"{Fore.BLUE}[i] Starting service detection on {target}{Style.RESET_ALL}")
        
        ports_str = ",".join([str(port) for port, _ in open_ports])
        
        try:
            nm = nmap.PortScanner()
            nm.scan(target, ports_str, arguments="-sV -T4")
            
            with open(f"{self.output_dir}/{target}_service_detection.txt", "w") as f:
                f.write(f"Service detection results for {target}\n")
                f.write("-" * 50 + "\n")
                
                for port in nm[target]['tcp']:
                    service = nm[target]['tcp'][port]
                    print(f"{Fore.GREEN}[+] Port {port}/tcp - {service['name']} {service['version']}{Style.RESET_ALL}")
                    f.write(f"{port}/tcp\t{service['name']}\t{service['product']} {service['version']}\n")
                    
            print(f"{Fore.GREEN}[+] Service detection completed. Results saved to {self.output_dir}/{target}_service_detection.txt{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[-] Error during service detection: {str(e)}{Style.RESET_ALL}")
    
    def directory_scan(self, target, port=80, wordlist=None):
        """Perform a web directory scan"""
        if port == 443:
            url_base = f"https://{target}"
        else:
            url_base = f"http://{target}:{port}"
            
        if not wordlist:
            # Small built-in wordlist for basic scanning
            dirs = [
                "/", "/admin", "/login", "/wp-admin", "/administrator", "/phpmyadmin",
                "/jenkins", "/wp-login.php", "/admin.php", "/index.php", "/robots.txt",
                "/backup", "/dev", "/test", "/tmp", "/api", "/docs", "/dashboard",
                "/config", "/old", "/new", "/upload", "/uploads", "/files", "/console",
                "/cgi-bin", "/web", "/secret", "/private", "/backup", "/images", "/img"
            ]
        else:
            try:
                with open(wordlist, "r") as f:
                    dirs = [line.strip() for line in f if line.strip()]
            except Exception as e:
                print(f"{Fore.RED}[-] Error reading wordlist: {str(e)}{Style.RESET_ALL}")
                return
        
        print(f"{Fore.BLUE}[i] Starting directory scan on {url_base} ({len(dirs)} paths){Style.RESET_ALL}")
        
        found_urls = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(self.check_url, f"{url_base}{d}"): d for d in dirs}
            
            for future in concurrent.futures.as_completed(futures):
                dir_path = futures[future]
                try:
                    url, status, size = future.result()
                    if url:  # If URL exists (status code < 400)
                        found_urls.append((url, status, size))
                        print(f"{Fore.GREEN}[+] Found: {url} (Status: {status}, Size: {size}){Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking {dir_path}: {str(e)}{Style.RESET_ALL}")
        
        # Save results
        with open(f"{self.output_dir}/{target}_directory_scan.txt", "w") as f:
            f.write(f"Directory scan results for {url_base}\n")
            f.write("-" * 50 + "\n")
            for url, status, size in found_urls:
                f.write(f"{url}\tStatus: {status}\tSize: {size}\n")
                
        print(f"{Fore.GREEN}[+] Directory scan completed. Found {len(found_urls)} paths. Results saved to {self.output_dir}/{target}_directory_scan.txt{Style.RESET_ALL}")
        return found_urls
    
    def check_url(self, url):
        """Check if a URL exists and return its status code and content size"""
        try:
            response = requests.get(url, timeout=3, verify=False, allow_redirects=True)
            if response.status_code < 400:  # Consider all non-error codes as "found"
                return url, response.status_code, len(response.content)
            return None, None, None
        except requests.exceptions.RequestException:
            return None, None, None
    
    def enumerate_subdomains(self, domain, wordlist=None):
        """Enumerate subdomains of a domain"""
        if not wordlist:
            # Small built-in wordlist for basic scanning
            subdomains = [
                "www", "mail", "ftp", "webmail", "login", "admin", "test", "dev",
                "portal", "ns1", "ns2", "smtp", "pop", "m", "blog", "mobile", "api",
                "secure", "vpn", "mx", "support", "remote", "docs", "web", "data", "server"
            ]
        else:
            try:
                with open(wordlist, "r") as f:
                    subdomains = [line.strip() for line in f if line.strip()]
            except Exception as e:
                print(f"{Fore.RED}[-] Error reading wordlist: {str(e)}{Style.RESET_ALL}")
                return
        
        print(f"{Fore.BLUE}[i] Starting subdomain enumeration for {domain} ({len(subdomains)} subdomains){Style.RESET_ALL}")
        
        found_subdomains = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            futures = {executor.submit(self.resolve_subdomain, f"{sub}.{domain}"): sub for sub in subdomains}
            
            for future in concurrent.futures.as_completed(futures):
                subdomain = futures[future]
                try:
                    full_domain, ip = future.result()
                    if ip:  # If subdomain resolves
                        found_subdomains.append((full_domain, ip))
                        print(f"{Fore.GREEN}[+] Found: {full_domain} ({ip}){Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking {subdomain}: {str(e)}{Style.RESET_ALL}")
        
        # Save results
        with open(f"{self.output_dir}/{domain}_subdomains.txt", "w") as f:
            f.write(f"Subdomain enumeration results for {domain}\n")
            f.write("-" * 50 + "\n")
            for subdomain, ip in found_subdomains:
                f.write(f"{subdomain}\t{ip}\n")
                
        print(f"{Fore.GREEN}[+] Subdomain enumeration completed. Found {len(found_subdomains)} subdomains. Results saved to {self.output_dir}/{domain}_subdomains.txt{Style.RESET_ALL}")
        return found_subdomains
    
    def resolve_subdomain(self, domain):
        """Resolve a subdomain to an IP address"""
        try:
            ip = socket.gethostbyname(domain)
            return domain, ip
        except socket.gaierror:
            return None, None
    
    def scan_network(self, target):
        """Full network scan - ping sweep, port scan and service detection"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting network scan on {target}{Style.RESET_ALL}")
        
        # Perform ping sweep to find live hosts
        live_hosts = self.ping_sweep(target)
        
        # Port scan each live host
        for host in live_hosts:
            open_ports = self.port_scan(host)
            
            # Perform service detection on hosts with open ports
            if open_ports and NMAP_AVAILABLE:
                self.service_detection(host, open_ports)
                
            # Check for web servers and perform directory scan
            for port, service in open_ports:
                if service in ["HTTP", "HTTPS"]:
                    self.directory_scan(host, port)
    
    def scan_target(self, target):
        """Full scan of a single target - port scan, service detection and dir scan"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting target scan on {target}{Style.RESET_ALL}")
        
        # Validate and resolve target
        resolved_target = self.validate_target(target)
        if not resolved_target:
            print(f"{Fore.RED}[-] Invalid target: {target}{Style.RESET_ALL}")
            return
            
        # Port scan
        open_ports = self.port_scan(resolved_target)
        
        # Perform service detection on hosts with open ports
        if open_ports and NMAP_AVAILABLE:
            self.service_detection(resolved_target, open_ports)
            
        # Check for web servers and perform directory scan
        for port, service in open_ports:
            if service in ["HTTP", "HTTPS"]:
                self.directory_scan(resolved_target, port)
    
    def scan_domain(self, domain):
        """Full domain scan - subdomain enum, port scan, service detection and dir scan"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting domain scan on {domain}{Style.RESET_ALL}")
        
        # Subdomain enumeration
        subdomains = self.enumerate_subdomains(domain)
        
        # Scan each subdomain
        for subdomain, ip in subdomains:
            open_ports = self.port_scan(ip)
            
            # Perform service detection
            if open_ports and NMAP_AVAILABLE:
                self.service_detection(ip, open_ports)
                
            # Check for web servers and perform directory scan
            for port, service in open_ports:
                if service in ["HTTP", "HTTPS"]:
                    self.directory_scan(subdomain, port)  # Use subdomain instead of IP for URL

    def wep_crack(self, capture_file=None, interface=None):
        """Crack WEP key from capture file or live capture"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting WEP key cracking{Style.RESET_ALL}")
        
        # Check for aircrack-ng
        try:
            subprocess.check_output(["which", "aircrack-ng"])
        except subprocess.CalledProcessError:
            print(f"{Fore.RED}[-] aircrack-ng not found. Please install it first.{Style.RESET_ALL}")
            return
        
        # Option to use provided capture file or perform live capture
        if capture_file:
            cmd = ["aircrack-ng", capture_file]
        elif interface:
            # This would involve setting up monitor mode, etc.
            print(f"{Fore.YELLOW}[!] Live capture not implemented yet. Use a capture file.{Style.RESET_ALL}")
            return
        else:
            print(f"{Fore.RED}[-] Either capture file or interface must be provided{Style.RESET_ALL}")
            return
        
        print(f"{Fore.GREEN}[+] Running aircrack-ng...{Style.RESET_ALL}")
        subprocess.call(cmd)

    def wpa_crack(self, capture_file, wordlist):
        """Crack WPA key from handshake capture using dictionary attack"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting WPA key cracking on {capture_file}{Style.RESET_ALL}")
        
        # Check for aircrack-ng
        try:
            subprocess.check_output(["which", "aircrack-ng"])
        except subprocess.CalledProcessError:
            print(f"{Fore.RED}[-] aircrack-ng not found. Please install it first.{Style.RESET_ALL}")
            return
        
        if not os.path.exists(wordlist):
            print(f"{Fore.RED}[-] Wordlist not found: {wordlist}{Style.RESET_ALL}")
            return
        
        cmd = ["aircrack-ng", capture_file, "-w", wordlist]
        print(f"{Fore.GREEN}[+] Running aircrack-ng with wordlist...{Style.RESET_ALL}")
        subprocess.call(cmd)

    def vulnerability_scan(self, target):
        """Perform a basic vulnerability scan using available tools"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting vulnerability scan on {target}{Style.RESET_ALL}")
        
        # Try to use nmap scripts for vulnerability scanning
        if NMAP_AVAILABLE:
            try:
                nm = nmap.PortScanner()
                print(f"{Fore.GREEN}[+] Running nmap vulnerability scripts...{Style.RESET_ALL}")
                # Using common vulnerability detection scripts
                nm.scan(target, arguments="-sV --script vuln -T4")
                
                with open(f"{self.output_dir}/{target}_vulnerability_scan.txt", "w") as f:
                    f.write(f"Vulnerability scan results for {target}\n")
                    f.write("-" * 50 + "\n")
                    f.write(nm.csv())
                    
                print(f"{Fore.GREEN}[+] Vulnerability scan completed. Results saved to {self.output_dir}/{target}_vulnerability_scan.txt{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}[-] Error during vulnerability scan: {str(e)}{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[!] Python-nmap not available. Install with: pip install python-nmap{Style.RESET_ALL}")

    def suggest_exploits(self, target, open_ports):
        """Suggest possible exploits based on service versions"""
        if not NMAP_AVAILABLE:
            print(f"{Fore.YELLOW}[!] Python-nmap not available. Install with: pip install python-nmap{Style.RESET_ALL}")
            return
            
        print(f"{Fore.BLUE}[i] Checking for possible exploits for {target}{Style.RESET_ALL}")
        
        try:
            nm = nmap.PortScanner()
            ports_str = ",".join([str(port) for port, _ in open_ports])
            nm.scan(target, ports_str, arguments="-sV")
            
            exploits_found = []
            
            for port in nm[target]['tcp']:
                service = nm[target]['tcp'][port]
                service_name = service['name']
                version = service['version']
                
                # Check common vulnerable services/versions
                # This is a simplified version - in reality, you'd want to check against
                # a database of known vulnerabilities
                if service_name == "ssh" and version.startswith("1."):
                    exploits_found.append((port, "SSH", version, "Possible weak crypto/authentication bypass"))
                elif service_name == "http" and "apache" in service['product'].lower():
                    if version.startswith("2.2") or version.startswith("2.4."):
                        exploits_found.append((port, "Apache", version, "Check for directory traversal, RCE vulnerabilities"))
                elif service_name == "smb" or service_name == "microsoft-ds":
                    exploits_found.append((port, "SMB", version, "Check for EternalBlue, SMB related vulnerabilities"))
                elif service_name == "ftp" and version.startswith("vs"):
                    exploits_found.append((port, "vsftpd", version, "Check for backdoor in vsftpd 2.3.4"))
                
            # Save results
            with open(f"{self.output_dir}/{target}_exploit_suggestions.txt", "w") as f:
                f.write(f"Exploit suggestions for {target}\n")
                f.write("-" * 50 + "\n")
                for port, service, version, suggestion in exploits_found:
                    f.write(f"Port {port}: {service} {version} - {suggestion}\n")
                    print(f"{Fore.GREEN}[+] Possible exploit: Port {port}: {service} {version} - {suggestion}{Style.RESET_ALL}")
                
                # Suggest searching for exploits in Metasploit
                f.write("\nSuggested Metasploit searches:\n")
                for port, service, version, _ in exploits_found:
                    f.write(f"search platform:unix type:exploit {service} {version}\n")
                    
            print(f"{Fore.GREEN}[+] Exploit suggestions saved to {self.output_dir}/{target}_exploit_suggestions.txt{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[-] Error suggesting exploits: {str(e)}{Style.RESET_ALL}")

    def brute_force(self, target, port, service, username_list=None, password_list=None):
        """Brute force login for common services (SSH, FTP, etc.)"""
        self.setup()
        
        if not username_list:
            username_list = ["admin", "root", "user", "test", "guest", "administrator", "oracle", "mysql"]
        elif os.path.isfile(username_list):
            with open(username_list, "r") as f:
                username_list = [line.strip() for line in f if line.strip()]
        
        if not password_list:
            password_list = ["password", "123456", "admin", "root", "toor", "test", "guest", "password123", ""]
        elif os.path.isfile(password_list):
            with open(password_list, "r") as f:
                password_list = [line.strip() for line in f if line.strip()]
        
        print(f"{Fore.BLUE}[i] Starting brute force on {target}:{port} ({service}){Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[!] Using {len(username_list)} usernames and {len(password_list)} passwords{Style.RESET_ALL}")
        
        # Create output file
        with open(f"{self.output_dir}/{target}_{port}_{service}_brute.txt", "w") as f:
            f.write(f"Brute force results for {target}:{port} ({service})\n")
            f.write("-" * 50 + "\n")
        
        if service.lower() == "ssh":
            self._brute_force_ssh(target, port, username_list, password_list)
        elif service.lower() == "ftp":
            self._brute_force_ftp(target, port, username_list, password_list)
        elif service.lower() in ["http", "https"]:
            form_url = input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter login form URL: ")
            if form_url:
                self._brute_force_web(form_url, username_list, password_list)
        else:
            print(f"{Fore.RED}[-] Service {service} not supported for brute forcing{Style.RESET_ALL}")

    def _brute_force_ssh(self, target, port, username_list, password_list):
        """Brute force SSH login"""
        try:
            import paramiko
        except ImportError:
            print(f"{Fore.YELLOW}[!] Paramiko module not installed. Install with: pip install paramiko{Style.RESET_ALL}")
            return
        
        paramiko.util.log_to_file(f"{self.output_dir}/paramiko.log")
        
        for username in username_list:
            for password in password_list:
                print(f"{Fore.BLUE}[i] Trying SSH: {username}:{password}{Style.RESET_ALL}", end="\r")
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(target, port=port, username=username, password=password, timeout=5)
                    
                    # If we get here, login successful
                    print(f"\n{Fore.GREEN}[+] SSH login successful! {username}:{password}{Style.RESET_ALL}")
                    with open(f"{self.output_dir}/{target}_{port}_ssh_brute.txt", "a") as f:
                        f.write(f"SUCCESS: {username}:{password}\n")
                    ssh.close()
                    return True
                except Exception:
                    pass
                finally:
                    try:
                        ssh.close()
                    except:
                        pass
        
        print(f"\n{Fore.RED}[-] SSH brute force finished. No valid credentials found.{Style.RESET_ALL}")
        return False

    def _brute_force_ftp(self, target, port, username_list, password_list):
        """Brute force FTP login"""
        import ftplib
        
        for username in username_list:
            for password in password_list:
                print(f"{Fore.BLUE}[i] Trying FTP: {username}:{password}{Style.RESET_ALL}", end="\r")
                try:
                    ftp = ftplib.FTP()
                    ftp.connect(target, port, timeout=5)
                    ftp.login(username, password)
                    
                    # If we get here, login successful
                    print(f"\n{Fore.GREEN}[+] FTP login successful! {username}:{password}{Style.RESET_ALL}")
                    with open(f"{self.output_dir}/{target}_{port}_ftp_brute.txt", "a") as f:
                        f.write(f"SUCCESS: {username}:{password}\n")
                    ftp.quit()
                    return True
                except Exception:
                    pass
                finally:
                    try:
                        ftp.quit()
                    except:
                        pass
        
        print(f"\n{Fore.RED}[-] FTP brute force finished. No valid credentials found.{Style.RESET_ALL}")
        return False

    def check_web_archive(self, domain, year=None, month=None):
        """Check Wayback Machine for archived versions of a website"""
        self.setup()
        
        print(f"{Fore.BLUE}[i] Checking Web Archive for {domain}{Style.RESET_ALL}")
        
        # Construct the URL for the Wayback CDX API
        url = f"http://web.archive.org/cdx/search/cdx?url={domain}&output=json&collapse=timestamp:4"
        
        if year:
            url += f"&from={year}"
            if month:
                month_str = str(month).zfill(2)
                url += f"{month_str}"
        
        try:
            response = requests.get(url)
            if response.status_code == 200:
                snapshots = response.json()
                
                # Skip the header row
                if len(snapshots) > 1:
                    snapshots = snapshots[1:]
                    
                    # Create output file
                    with open(f"{self.output_dir}/{domain}_archive.txt", "w") as f:
                        f.write(f"Web Archive results for {domain}\n")
                        f.write("-" * 50 + "\n")
                        
                        print(f"{Fore.GREEN}[+] Found {len(snapshots)} archived snapshots{Style.RESET_ALL}")
                        
                        for snapshot in snapshots:
                            timestamp = snapshot[1]
                            url = snapshot[2]
                            archive_url = f"https://web.archive.org/web/{timestamp}/{url}"
                            
                            year = timestamp[:4]
                            month = timestamp[4:6]
                            day = timestamp[6:8]
                            
                            print(f"{Fore.GREEN}[+] {year}-{month}-{day}: {archive_url}{Style.RESET_ALL}")
                            f.write(f"{year}-{month}-{day}: {archive_url}\n")
                            
                    print(f"{Fore.GREEN}[+] Web Archive results saved to {self.output_dir}/{domain}_archive.txt{Style.RESET_ALL}")
                else:
                    print(f"{Fore.YELLOW}[!] No archived snapshots found for {domain}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[-] Failed to query Web Archive. Status code: {response.status_code}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[-] Error checking Web Archive: {str(e)}{Style.RESET_ALL}")

    def find_hidden_content(self, target, port=80):
        """Find hidden files, directories and admin pages using specialized wordlists"""
        self.setup()
        
        # Specialized wordlists for admin pages and hidden content
        admin_pages = [
            "/admin", "/administrator", "/admin.php", "/admin.html", "/login", "/login.php",
            "/wp-admin", "/administrator", "/backend", "/control", "/cpanel", "/panel",
            "/admin-login", "/adm", "/user", "/users", "/account", "/accounts", "/manage",
            "/manager", "/management", "/signin", "/dashboard", "/cms", "/system", 
            "/portal", "/webadmin", "/admincp", "/moderator", "/cp", "/controlpanel", 
            "/adminpanel", "/admin-panel", "/cmsadmin", "/siteadmin"
        ]
        
        # Hidden content can include things like robots.txt disallowed entries
        hidden_content = [
            "/robots.txt", "/.htaccess", "/.git", "/.svn", "/.env", "/config", 
            "/backup", "/backups", "/bak", "/old", "/new", "/dev", "/test", "/temp",
            "/web.config", "/server-status", "/server-info", "/_vti_bin", "/_vti_pvt",
            "/.well-known", "/api", "/phpinfo.php", "/info.php", "/asd"
        ]
        
        # Combine the lists but scan admin pages first
        dirs = admin_pages + hidden_content
        
        if port == 443:
            url_base = f"https://{target}"
        else:
            url_base = f"http://{target}:{port}"
        
        print(f"{Fore.BLUE}[i] Starting hidden content scan on {url_base}{Style.RESET_ALL}")
        
        found_urls = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(self.check_url, f"{url_base}{d}"): d for d in dirs}
            
            for future in concurrent.futures.as_completed(futures):
                dir_path = futures[future]
                try:
                    url, status, size = future.result()
                    if url:  # If URL exists (status code < 400)
                        found_urls.append((url, status, size))
                        if dir_path in admin_pages:
                            print(f"{Fore.GREEN}[+] Found admin page: {url} (Status: {status}, Size: {size}){Style.RESET_ALL}")
                        else:
                            print(f"{Fore.GREEN}[+] Found hidden content: {url} (Status: {status}, Size: {size}){Style.RESET_ALL}")
                except Exception as e:
                    print(f"{Fore.RED}[-] Error checking {dir_path}: {str(e)}{Style.RESET_ALL}")
        
        # Also check robots.txt specifically to find disallowed entries
        try:
            robots_url = f"{url_base}/robots.txt"
            response = requests.get(robots_url, timeout=3, verify=False)
            
            if response.status_code == 200:
                print(f"{Fore.GREEN}[+] Found robots.txt, checking for disallowed entries{Style.RESET_ALL}")
                lines = response.text.split('\n')
                disallowed = []
                
                for line in lines:
                    if line.lower().startswith('disallow:'):
                        path = line.split(':', 1)[1].strip()
                        if path and path != '/':
                            disallowed.append(path)
                            print(f"{Fore.YELLOW}[!] Disallowed path: {path}{Style.RESET_ALL}")
                            
                            # Check if the disallowed path exists
                            full_url = f"{url_base}{path}"
                            self.check_url(full_url)
        except:
            pass
                    
        # Save results
        with open(f"{self.output_dir}/{target}_hidden_content.txt", "w") as f:
            f.write(f"Hidden content scan results for {url_base}\n")
            f.write("-" * 50 + "\n")
            
            if found_urls:
                f.write("Admin pages found:\n")
                for url, status, size in found_urls:
                    if any(admin in url for admin in admin_pages):
                        f.write(f"{url}\tStatus: {status}\tSize: {size}\n")
                
                f.write("\nOther hidden content:\n")
                for url, status, size in found_urls:
                    if not any(admin in url for admin in admin_pages):
                        f.write(f"{url}\tStatus: {status}\tSize: {size}\n")
            else:
                f.write("No hidden content found.\n")
                
        print(f"{Fore.GREEN}[+] Hidden content scan completed. Found {len(found_urls)} items. Results saved to {self.output_dir}/{target}_hidden_content.txt{Style.RESET_ALL}")
        return found_urls

    def extract_image_metadata(self, image_path):
        """Extract metadata from an image"""
        self.setup()
        
        if not os.path.exists(image_path):
            print(f"{Fore.RED}[-] Image not found: {image_path}{Style.RESET_ALL}")
            return
        
        print(f"{Fore.BLUE}[i] Extracting metadata from {image_path}{Style.RESET_ALL}")
        
        # Try to use exiftool if available
        try:
            output = subprocess.check_output(["exiftool", image_path], universal_newlines=True)
            
            # Create output file
            with open(f"{self.output_dir}/image_metadata.txt", "w") as f:
                f.write(f"Metadata for {image_path}\n")
                f.write("-" * 50 + "\n")
                f.write(output)
                
            print(f"{Fore.GREEN}[+] Metadata extracted. Results saved to {self.output_dir}/image_metadata.txt{Style.RESET_ALL}")
            
            # Check for GPS coordinates
            gps_lat = None
            gps_lon = None
            
            for line in output.split('\n'):
                if "GPS Latitude" in line:
                    gps_lat = line.split(':', 1)[1].strip()
                    print(f"{Fore.GREEN}[+] Found GPS Latitude: {gps_lat}{Style.RESET_ALL}")
                elif "GPS Longitude" in line:
                    gps_lon = line.split(':', 1)[1].strip()
                    print(f"{Fore.GREEN}[+] Found GPS Longitude: {gps_lon}{Style.RESET_ALL}")
            
            if gps_lat and gps_lon:
                print(f"{Fore.GREEN}[+] Google Maps URL: https://maps.google.com/?q={gps_lat},{gps_lon}{Style.RESET_ALL}")
                
        except subprocess.CalledProcessError:
            print(f"{Fore.RED}[-] Error extracting metadata with exiftool{Style.RESET_ALL}")
        except FileNotFoundError:
            print(f"{Fore.YELLOW}[!] exiftool not found. Please install it or use PIL.{Style.RESET_ALL}")
            
            # Try using PIL as fallback
            try:
                from PIL import Image
                from PIL.ExifTags import TAGS, GPSTAGS
                
                image = Image.open(image_path)
                exifdata = image._getexif()
                
                if exifdata:
                    with open(f"{self.output_dir}/image_metadata.txt", "w") as f:
                        f.write(f"Metadata for {image_path}\n")
                        f.write("-" * 50 + "\n")
                        
                        for tag_id in exifdata:
                            tag = TAGS.get(tag_id, tag_id)
                            data = exifdata.get(tag_id)
                            
                            if isinstance(data, bytes):
                                data = data.decode(errors='replace')
                                
                            print(f"{Fore.GREEN}[+] {tag}: {data}{Style.RESET_ALL}")
                            f.write(f"{tag}: {data}\n")
                    
                    print(f"{Fore.GREEN}[+] Metadata extracted with PIL. Results saved to {self.output_dir}/image_metadata.txt{Style.RESET_ALL}")
                else:
                    print(f"{Fore.YELLOW}[!] No EXIF data found in the image{Style.RESET_ALL}")
            except ImportError:
                print(f"{Fore.RED}[-] PIL not installed. Install with: pip install pillow{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}[-] Error extracting metadata with PIL: {str(e)}{Style.RESET_ALL}")

    def os_detection(self, target):
        """Perform detailed OS detection"""
        self.setup()
        print(f"{Fore.BLUE}[i] Starting OS detection for {target}{Style.RESET_ALL}")
        
        if not NMAP_AVAILABLE:
            print(f"{Fore.YELLOW}[!] Python-nmap not available. Install with: pip install python-nmap{Style.RESET_ALL}")
            return None
        
        try:
            nm = nmap.PortScanner()
            nm.scan(target, arguments="-O -T4")
            
            os_matches = []
            
            if target in nm.all_hosts() and 'osmatch' in nm[target]:
                for osmatch in nm[target]['osmatch']:
                    os_name = osmatch['name']
                    accuracy = osmatch['accuracy']
                    os_matches.append((os_name, accuracy))
                    print(f"{Fore.GREEN}[+] OS detected: {os_name} (Accuracy: {accuracy}%){Style.RESET_ALL}")
            
            # Save results
            with open(f"{self.output_dir}/{target}_os_detection.txt", "w") as f:
                f.write(f"OS detection results for {target}\n")
                f.write("-" * 50 + "\n")
                
                if os_matches:
                    for os_name, accuracy in os_matches:
                        f.write(f"OS: {os_name} (Accuracy: {accuracy}%)\n")
                else:
                    f.write("No OS matches found\n")
            
            print(f"{Fore.GREEN}[+] OS detection completed. Results saved to {self.output_dir}/{target}_os_detection.txt{Style.RESET_ALL}")
            
            # Return the most likely OS (highest accuracy)
            if os_matches:
                return sorted(os_matches, key=lambda x: int(x[1]), reverse=True)[0][0]
            return None
        except Exception as e:
            print(f"{Fore.RED}[-] Error during OS detection: {str(e)}{Style.RESET_ALL}")
            return None


def banner():
    """Display script banner"""
    banner_text = f"""
{Fore.RED}
██╗  ██╗███████╗██╗  ██╗
██║ ██╔╝██╔════╝╚██╗██╔╝
█████╔╝ █████╗   ╚███╔╝ 
██╔═██╗ ██╔══╝   ██╔██╗ 
██║  ██╗███████╗██╔╝ ██╗
╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
{Style.RESET_ALL}
{Fore.WHITE}========== Interactive Penetration Testing Tool v1.0 =========={Style.RESET_ALL}
{Fore.RED}================= For Educational Use Only ==================={Style.RESET_ALL}
"""
    print(banner_text)


def display_menu():
    """Display the main menu with new options"""
    os.system('cls' if os.name == 'nt' else 'clear')
    banner()
    print(f"{Fore.CYAN}┌───────────────────────────────────────────────────┐{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.WHITE}{Back.BLUE} PENTEST HELPER - MAIN MENU                      {Style.RESET_ALL} {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}1.{Style.RESET_ALL} Single Target Scan                              {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}2.{Style.RESET_ALL} Network Scan                                    {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}3.{Style.RESET_ALL} Domain Scan (with Subdomains)                   {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}4.{Style.RESET_ALL} Ping Sweep                                      {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}5.{Style.RESET_ALL} Port Scan                                       {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}6.{Style.RESET_ALL} Service Detection                               {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}7.{Style.RESET_ALL} Directory Scan                                  {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}8.{Style.RESET_ALL} Subdomain Enumeration                           {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}9.{Style.RESET_ALL} Vulnerability Scan                              {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}10.{Style.RESET_ALL} OS Detection                                    {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}11.{Style.RESET_ALL} Find Hidden Content                             {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}12.{Style.RESET_ALL} Password Brute Force                            {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}13.{Style.RESET_ALL} Wireless Tools                                  {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}14.{Style.RESET_ALL} OSINT Tools                                     {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}15.{Style.RESET_ALL} Extract Image Metadata                          {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}├───────────────────────────────────────────────────┤{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│{Style.RESET_ALL} {Fore.YELLOW}0.{Style.RESET_ALL} Exit                                            {Fore.CYAN}│{Style.RESET_ALL}")
    print(f"{Fore.CYAN}└───────────────────────────────────────────────────┘{Style.RESET_ALL}")
    print()
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Choose an option: ")

def get_target():
    """Get target from user"""
    
    print(f"{Fore.CYAN}================{Style.RESET_ALL} {Fore.WHITE}{Back.BLUE} TARGET INFORMATION{Style.RESET_ALL} {Fore.CYAN}================{Style.RESET_ALL}")
    print(f"\n{Fore.YELLOW}[i] {Style.RESET_ALL}Examples:")
    print(f"   - Single IP:      192.168.1.1")
    print(f"   - Network range:  192.168.1.0/24")
    print(f"   - Domain:         example.com")
    print()
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter target: ")

def get_ports():
    """Get ports from user"""
    print()
    print(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Examples: 80,443,8080 or leave empty for common ports")
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter ports (comma-separated) or press Enter for defaults: ")

def get_wordlist(type_str):
    """Get wordlist file path from user"""
    print()
    print(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Leave empty to use built-in wordlist")
    return input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter {type_str} wordlist path or press Enter for default: ")

def confirm_action(action, target):
    """Confirm action with user"""
    print()
    print(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Ready to {action} {target}")
    confirm = input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Proceed? (Y/n): ").strip().lower()
    return confirm != 'n'

def display_results_location(directory):
    """Display where results are saved"""
    print()
    print(f"{Fore.CYAN}================{Style.RESET_ALL}")
    print(f"{Fore.CYAN}================{Style.RESET_ALL}")
    print(f"\n{Fore.GREEN}[+] {Style.RESET_ALL}Results saved in: {directory}")
    print()
    input(f"{Fore.YELLOW}[i] {Style.RESET_ALL}Press Enter to continue...")

def main():
    """Main function for interactive menu"""
    pentest = PenTester()
    
    while True:
        option = display_menu()
        
        if option == "0":
            print(f"\n{Fore.GREEN}[+] {Style.RESET_ALL}Goodbye!")
            sys.exit(0)
            
        elif option == "1":  # Single Target Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform full scan on", target):
                pentest.setup()
                pentest.scan_target(target)
                display_results_location(pentest.output_dir)
                
        elif option == "2":  # Network Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("scan network", target):
                pentest.setup()
                pentest.scan_network(target)
                display_results_location(pentest.output_dir)
                
        elif option == "3":  # Domain Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("scan domain", target):
                pentest.setup()
                pentest.scan_domain(target)
                display_results_location(pentest.output_dir)
                
        elif option == "4":  # Ping Sweep
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform ping sweep on", target):
                pentest.setup()
                pentest.ping_sweep(target)
                display_results_location(pentest.output_dir)
                
        elif option == "5":  # Port Scan
            target = get_target()
            if not target:
                continue
                
            ports_input = get_ports()
            
            if confirm_action("perform port scan on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    if ports_input:
                        ports = [int(p.strip()) for p in ports_input.split(",") if p.strip()]
                        pentest.port_scan(target_ip, ports)
                    else:
                        pentest.port_scan(target_ip)
                        
                display_results_location(pentest.output_dir)
                
        elif option == "6":  # Service Detection
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform service detection on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    open_ports = pentest.port_scan(target_ip)
                    if open_ports and NMAP_AVAILABLE:
                        pentest.service_detection(target_ip, open_ports)
                    elif not NMAP_AVAILABLE:
                        print(f"{Fore.RED}[-] {Style.RESET_ALL}Python-nmap not available. Install with: pip install python-nmap")
                        time.sleep(3)
                        
                display_results_location(pentest.output_dir)
                
        elif option == "7":  # Directory Scan
            target = get_target()
            if not target:
                continue
                
            ports_input = get_ports()
            wordlist = get_wordlist("directory")
            
            if confirm_action("perform directory scan on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    if ports_input:
                        port = int(ports_input.split(",")[0].strip())
                    else:
                        port = 80
                        
                    pentest.directory_scan(target_ip, port, wordlist if wordlist else None)
                    
                display_results_location(pentest.output_dir)
                
        elif option == "8":  # Subdomain Enumeration
            target = get_target()
            if not target:
                continue
                
            wordlist = get_wordlist("subdomain")
            
            if confirm_action("perform subdomain enumeration on", target):
                pentest.setup()
                pentest.enumerate_subdomains(target, wordlist if wordlist else None)
                display_results_location(pentest.output_dir)
        
        elif option == "9":  # Vulnerability Scan
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform vulnerability scan on", target):
                pentest.setup()
                pentest.vulnerability_scan(target)
                display_results_location(pentest.output_dir)
                
        elif option == "10":  # OS Detection
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform OS detection on", target):
                pentest.setup()
                pentest.os_detection(target)
                display_results_location(pentest.output_dir)
                
        elif option == "11":  # Find Hidden Content
            target = get_target()
            if not target:
                continue
                
            ports_input = get_ports()
            
            if confirm_action("find hidden content on", target):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    if ports_input:
                        port = int(ports_input.split(",")[0].strip())
                    else:
                        port = 80
                        
                    pentest.find_hidden_content(target_ip, port)
                    
                display_results_location(pentest.output_dir)
                
        elif option == "12":  # Password Brute Force
            target = get_target()
            if not target:
                continue
                
            ports_input = get_ports()
            service = input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter service (ssh/ftp/http): ").strip().lower()
            
            if service not in ["ssh", "ftp", "http"]:
                print(f"{Fore.RED}[-] Invalid service. Must be ssh, ftp, or http{Style.RESET_ALL}")
                continue
                
            if confirm_action("perform brute force attack on", f"{target} ({service})"):
                pentest.setup()
                target_ip = pentest.validate_target(target)
                
                if target_ip:
                    if ports_input:
                        port = int(ports_input.split(",")[0].strip())
                    else:
                        port = 22 if service == "ssh" else 21 if service == "ftp" else 80
                        
                    pentest.brute_force(target_ip, port, service)
                    
                display_results_location(pentest.output_dir)
                
        elif option == "13":  # Wireless Tools
            print(f"\n{Fore.YELLOW}[!] Wireless tools not yet implemented{Style.RESET_ALL}")
            time.sleep(1)
            
        elif option == "14":  # OSINT Tools
            target = get_target()
            if not target:
                continue
                
            if confirm_action("perform OSINT on", target):
                pentest.setup()
                pentest.check_web_archive(target)
                display_results_location(pentest.output_dir)
                
        elif option == "15":  # Extract Image Metadata
            image_path = input(f"{Fore.GREEN}[+] {Style.RESET_ALL}Enter path to image file: ").strip()
            
            if confirm_action("extract metadata from", image_path):
                pentest.setup()
                pentest.extract_image_metadata(image_path)
                display_results_location(pentest.output_dir)
        
        else:
            print(f"\n{Fore.RED}[-] {Style.RESET_ALL}Invalid option! Please try again.")
            time.sleep(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Scan interrupted by user{Style.RESET_ALL}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Fore.RED}[-] An error occurred: {str(e)}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[!] {Style.RESET_ALL}Press Enter to continue...")
        input()
        sys.exit(1)